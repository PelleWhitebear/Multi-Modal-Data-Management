import cv2
import time
import tempfile
import os
import logging
import io
from PIL import Image
import numpy as np
import dotenv
from chromadb import HttpClient
from chromadb.utils.embedding_functions import OpenCLIPEmbeddingFunction
from global_scripts.utils import minio_init, chroma_init, load_games_from_minio

dotenv.load_dotenv(dotenv.find_dotenv())

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [%(levelname)s] - %(message)s',
    force=True  # override any existing config
)

def create_collections(chroma_client):
    """
    Create ChromaDB collections for text, image, and video embeddings if they don't exist.

    :param chroma_client: ChromaDB client
    """
    try:
        collections = chroma_client.list_collections()
        for collection in collections:
            chroma_client.delete_collection(name=collection.name)
        logging.info(f"ChromaDB collections found: {[collection.name for collection in collections]}, deleting all existing collections.")
        collection_names = [f"text_{time.strftime('%Y%m%d')}", f"image_{time.strftime('%Y%m%d')}", f"video_{time.strftime('%Y%m%d')}"]
        
        for collection_name in collection_names:
            logging.info(f"ChromaDB collection '{collection_name}' does not exist, creating a new one.")
            chroma_client.create_collection(name=collection_name, embedding_function=OpenCLIPEmbeddingFunction())
            
        logging.info(f"ChromaDB collections created.")
        return
    except Exception:
        logging.info("Error creating/fetching ChromaDB collections.")
        return
    

def main():
    # MinIO client connection, using Amazon S3 API and boto3 Python library
    s3_client = minio_init()

    # ChromaDB client connection
    chroma_client = chroma_init()
    
    # Fetching game data from MinIO
    games = load_games_from_minio(s3_client, os.getenv("EXPLOITATION_ZONE_BUCKET"), "json/", "enhanced_games.json")
    
    # Create collections if they don't exist
    create_collections(chroma_client)

    # Creating text embeddings:
    try:
        logging.info("Creating text embeddings...")
        text_collection = chroma_client.get_collection(f"text_{time.strftime('%Y%m%d')}")
        
        pairs = [(game_id, game_data['final_description']) for game_id, game_data in games.items() if 'final_description' in game_data and game_data['final_description'].strip() != '']
        text_collection.add(
            ids=[pair[0] for pair in pairs],
            documents=[pair[1] for pair in pairs]
        )
        logging.info("Text embeddings created and added to ChromaDB.")

    except Exception:
        logging.exception("Error creating text embeddings.")
        return

    # Fetching image data from MinIO
    try:
        logging.info("Fetching image files from MinIO...")
        image_collection = chroma_client.get_collection(f"image_{time.strftime('%Y%m%d')}")
        images = []
        objs = s3_client.list_objects_v2(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Prefix="media/image/")
        if "Contents" not in objs:
            logging.error("No image files found.")
            return
        seen_images = set()
        for obj in objs["Contents"]:
            if obj["Key"].lower().endswith('.jpg'):
                # Convert image to numpy array
                image_obj = s3_client.get_object(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Key=obj["Key"])
                image_id = f"{obj['Key'].split('#')[1]}_{obj['Key'].split('#')[-1].split('.')[0]}"  # gameID_screenshotID
                if image_id in seen_images:
                    continue
                seen_images.add(image_id)
                image_data = image_obj["Body"].read()
                image_array = np.array(Image.open(io.BytesIO(image_data)))
                images.append((image_id, image_array)) # Don't need to differentiate between screenshots for the same game
        logging.info(f"Fetched {len(images)} images from MinIO.")

    except Exception:
        logging.exception("Error fetching image files from MinIO.")
        return
    
    # Creating image embeddings:
    try:
        logging.info("Creating image embeddings...")
        image_collection = chroma_client.get_collection(f"image_{time.strftime('%Y%m%d')}")
        image_collection.add(
            ids=[img[0] for img in images],
            images=[img[1] for img in images]
        )
        logging.info("Image embeddings created and added to ChromaDB.")
        
    except Exception:
        logging.exception("Error creating image embeddings.")
        return
    
    # Fetching video data from MinIO
    try:
        logging.info("Fetching video files from MinIO...")
        video_collection = chroma_client.get_collection(f"video_{time.strftime('%Y%m%d')}")
        
        objs = s3_client.list_objects_v2(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Prefix="media/video/")
        if "Contents" not in objs:
            logging.error("No video files found.")
            return
        logging.info(f"Fetched {len(objs['Contents'])} videos from MinIO.")

    except Exception:
        logging.exception("Error fetching video files from MinIO.")
        return

    # Creating video embeddings:
    vids = []
    embedding_function = OpenCLIPEmbeddingFunction()

    # For each video, sample 10 frames and convert to numpy arrays
    for obj in objs["Contents"]:
        if obj["Key"].lower().endswith('.mp4'):
            try:
                
                video_obj = s3_client.get_object(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Key=obj["Key"])
                video_id = obj["Key"].split("#")[1]
                video_data = video_obj["Body"].read()
                with tempfile.NamedTemporaryFile(suffix=".mp4", delete=True) as tmp:
                    tmp.write(video_data)
                    tmp.flush()
                    cap = cv2.VideoCapture(tmp.name)
                    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
                    if total_frames <= 0:
                        logging.warning(f"Video file {obj['Key']} has no frames. Skipping.")
                        continue

                    # Sample evenly spaced frames, leaving out first and last frames
                    frame_count = 0
                    frame_indices = np.linspace(0, total_frames - 1, int(os.getenv("NUM_FRAMES")) + 2, dtype=int)
                    frames_to_embed = []
                    for frame_idx in frame_indices[1:-1]:  # Skip first and last frames -> Black frames
                        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)
                        ret, frame = cap.read()
                        if ret:
                            # Convert from BGR to RGB
                            frame_count += 1
                            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                            numpy_frame = np.array(frame_rgb)
                            frames_to_embed.append(numpy_frame)
                    
                    if frames_to_embed:
                        logging.info(f"Embedding {len(frames_to_embed)} frames for video {obj['Key']} in a batch...")
                        embeddings = embedding_function(frames_to_embed)
                        vids.append((video_id, np.mean(embeddings, axis=0)))
                        logging.info(f"Batch embedding for video {obj['Key']} complete.")
                    cap.release()
                    logging.info(f"Extracted {frame_count} frames from video {obj['Key']}.")

            except Exception:
                logging.exception(f"Error processing video file {obj['Key']}. Skipping.")
                continue
    
    # Creating video embeddings:
    try:
        logging.info("Creating video embeddings...")
        video_collection = chroma_client.get_collection(f"video_{time.strftime('%Y%m%d')}")
        video_collection.add(
            ids=[vid[0] for vid in vids],
            embeddings=[vid[1] for vid in vids]
        )
        logging.info("Video embeddings created and added to ChromaDB.")

    except Exception:
        logging.exception("Error creating video embeddings.")
        return

    logging.info("Embedding creation process completed.")
if __name__ == "__main__":
    main()