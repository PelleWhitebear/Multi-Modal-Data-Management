import cv2
import time
import tempfile
import os
import boto3
import logging
import json
import io
from PIL import Image
import numpy as np
import dotenv
from chromadb import HttpClient
from chromadb.utils.embedding_functions import OpenCLIPEmbeddingFunction

dotenv.load_dotenv(dotenv.find_dotenv())

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [%(levelname)s] - %(message)s',
    force=True  # override any existing config
)

def main():
    # MinIO client connection, using Amazon S3 API and boto3 Python library
    try:
        s3_client = boto3.client(
            "s3",
            endpoint_url=os.getenv("ENDPOINT_URL"),
            aws_access_key_id=os.getenv("AWS_ACCESS_KEY_ID"),
            aws_secret_access_key=os.getenv("AWS_SECRET_ACCESS_KEY"),
        )
        logging.info("Connected to MinIO.")

    except Exception:
        logging.exception("Error connecting to MinIO.")
        return
    
    # Booting up ChromaDB
    try:
        chroma_client = HttpClient(
            host="chroma",
            port=8000
        )
        logging.info("Connected to ChromaDB.")
    except Exception:
        logging.exception("Error connecting to ChromaDB.")
        return
    
    # Fetching game data from MinIO
    try:
        objs = s3_client.list_objects_v2(Bucket=os.getenv("EXPLOITATION_ZONE_BUCKET"), Prefix="json/")
        if "Contents" not in objs:
            logging.error("No JSON files found in exploitation-zone.")
            return
        filename = ""
        for obj in objs["Contents"]:
            if obj["Key"].endswith("enhanced_games.json"):
                filename = obj["Key"]
                break

        game_obj = s3_client.get_object(Bucket=os.getenv("EXPLOITATION_ZONE_BUCKET"), Key=filename)
        games = json.loads(game_obj["Body"].read().decode("utf-8"))
        logging.info(f"Game data fetched.")
    
    except Exception:
        logging.exception("Error fetching game JSON from MinIO.")
        return

    # Create collections if they don't exist
    try:
        collections = chroma_client.list_collections()
        logging.info(f"ChromaDB collections found: {[collection.name for collection in collections]}")
        collection_names = [f"text_{time.strftime('%Y%m%d')}", f"image_{time.strftime('%Y%m%d')}", f"video_{time.strftime('%Y%m%d')}"]
        for collection in collections:
            if collection.name not in collection_names:
                collection_names.remove(collection.name)
                logging.info(f"ChromaDB collection '{collection.name}' already exists from a previous date. Deleting it.")
        
        for collection_name in collection_names:
            if collection_name not in [collection.name for collection in collections]:
                logging.info(f"ChromaDB collection '{collection_name}' does not exist, creating a new one.")
                chroma_client.create_collection(name=collection_name, embedding_function=OpenCLIPEmbeddingFunction())
            else:
                logging.info(f"ChromaDB collection '{collection_name}' already exists.")
        logging.info(f"ChromaDB collections created.")

    except Exception:
        logging.info("Error creating/fetching ChromaDB collections.")
        return


    # Creating text embeddings:
    try:
        logging.info("Creating text embeddings...")
        text_collection = chroma_client.get_collection(f"text_{time.strftime('%Y%m%d')}")
        # Check if collection is empty before adding
        upload_text = text_collection.count() == 0
        if not upload_text:
            logging.info("Text collection already has data, skipping addition.")

        else:
            pairs = [(game_id, game_data['final_description']) for game_id, game_data in games.items() if 'final_description' in game_data and game_data['final_description'].strip() != '']
            text_collection.add(
                ids=[pair[0] for pair in pairs],
                documents=[pair[1] for pair in pairs]
            )
            logging.info("Text embeddings created and added to ChromaDB.")

    except Exception:
        logging.exception("Error creating text embeddings.")
        return

    # Fetching image data from MinIO
    try:
        logging.info("Fetching image files from MinIO...")
        image_collection = chroma_client.get_collection(f"image_{time.strftime('%Y%m%d')}")
        upload_image = image_collection.count() == 0
        if not upload_image:
            logging.info("Image collection already has data, skipping fetch.")
        
        else:
            images = []
            objs = s3_client.list_objects_v2(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Prefix="media/image/")
            if "Contents" not in objs:
                logging.error("No image files found.")
                return
            for obj in objs["Contents"]:
                if obj["Key"].lower().endswith('.jpg'):
                    # Convert image to numpy array
                    image_obj = s3_client.get_object(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Key=obj["Key"])
                    image_id = f"{obj['Key'].split('#')[1]}_{obj['Key'].split('#')[-1].split('.')[0]}"  # gameID_screenshotID
                    image_data = image_obj["Body"].read()
                    image_array = np.array(Image.open(io.BytesIO(image_data)))
                    images.append((image_id, image_array)) # Don't need to differentiate between screenshots for the same game
            logging.info(f"Fetched {len(images)} images from MinIO.")

    except Exception:
        logging.exception("Error fetching image files from MinIO.")
        return
    
    # Creating image embeddings:
    try:
        logging.info("Creating image embeddings...")
        if upload_image:
            image_collection = chroma_client.get_collection(f"image_{time.strftime('%Y%m%d')}")
            image_collection.add(
                ids=[img[0] for img in images],
                images=[img[1] for img in images]
            )
            logging.info("Image embeddings created and added to ChromaDB.")
        else:
            logging.info("Image embeddings already exist, skipping creation.")

    except Exception:
        logging.exception("Error creating image embeddings.")
        return
    
    # Fetching video data from MinIO
    try:
        logging.info("Fetching video files from MinIO...")
        video_collection = chroma_client.get_collection(f"video_{time.strftime('%Y%m%d')}")
        upload_video = video_collection.count() == 0
        if not upload_video:
            logging.info("Video collection already has data, skipping fetch.")

        else:
            objs = s3_client.list_objects_v2(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Prefix="media/video/")
            if "Contents" not in objs:
                logging.error("No video files found.")
                return
            logging.info(f"Fetched {len(objs['Contents'])} videos from MinIO.")

    except Exception:
        logging.exception("Error fetching video files from MinIO.")
        return

    # Creating video embeddings:
    vids = []
    embedding_function = OpenCLIPEmbeddingFunction()
    if upload_video:
        for obj in objs["Contents"]:
            if obj["Key"].lower().endswith('.mp4'):
                try:
                    # Sample 5 frames from each video and convert to numpy arrays
                    video_obj = s3_client.get_object(Bucket=os.getenv("FORMATTED_ZONE_BUCKET"), Key=obj["Key"])
                    video_id = obj["Key"].split("#")[1]
                    video_data = video_obj["Body"].read()
                    with tempfile.NamedTemporaryFile(suffix=".mp4", delete=True) as tmp:
                        tmp.write(video_data)
                        tmp.flush()
                        cap = cv2.VideoCapture(tmp.name)
                        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
                        if total_frames <= 0:
                            logging.warning(f"Video file {obj['Key']} has no frames. Skipping.")
                            continue

                        # Sample evenly spaced frames, leaving out first and last frames
                        frame_count = 0
                        frame_indices = np.linspace(0, total_frames - 1, int(os.getenv("NUM_FRAMES")) + 2, dtype=int)
                        frames_to_embed = []
                        for frame_idx in frame_indices[1:-1]:  # Skip first and last frames -> Black frames
                            cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)
                            ret, frame = cap.read()
                            if ret:
                                # Convert from BGR to RGB
                                frame_count += 1
                                frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                                numpy_frame = np.array(frame_rgb)
                                frames_to_embed.append(numpy_frame)
                        
                        if frames_to_embed:
                            logging.info(f"Embedding {len(frames_to_embed)} frames for video {obj['Key']} in a batch...")
                            embeddings = embedding_function(frames_to_embed)
                            vids.append((video_id, np.mean(embeddings, axis=0)))
                            logging.info(f"Batch embedding for video {obj['Key']} complete.")
                        cap.release()
                        logging.info(f"Extracted {frame_count} frames from video {obj['Key']}.")

                except Exception:
                    logging.exception(f"Error processing video file {obj['Key']}. Skipping.")
                    continue
    
    # Creating video embeddings:
    try:
        if upload_video:
            logging.info("Creating video embeddings...")
            video_collection = chroma_client.get_collection(f"video_{time.strftime('%Y%m%d')}")
            video_collection.add(
                ids=[vid[0] for vid in vids],
                embeddings=[vid[1] for vid in vids]
            )
            logging.info("Video embeddings created and added to ChromaDB.")

        else:
            logging.info("Video embeddings already exist, skipping creation.")
        
        logging.info("Embedding creation process completed.")

    except Exception:
        logging.exception("Error creating video embeddings.")
        return

if __name__ == "__main__":
    main()